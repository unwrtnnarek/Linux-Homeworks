#include <iostream>
#include <vector>
#include <pthread.h>
#include <random>
#include <algorithm>
#include <chrono>
#include <cstring>

class TaskData
{
public:
    pthread_t thread_id;
    int* data_ptr;
    int seg_begin;
    int seg_end;
    double partial_sum;
};

void* worker(void* arg)
{
    TaskData* info = static_cast<TaskData*>(arg);
    
    int length = info->seg_end - info->seg_begin;
    if(length == 0)
    {
        info->partial_sum = 0.0;
        return arg;
    }

    double total = 0.0;

    for(int i = info->seg_begin; i < info->seg_end; ++i)
    {
        total += info->data_ptr[i];
    }

    info->partial_sum = total;
    return arg;
}

int main(int argc, char** argv)
{
    if(argc < 3)
    {
        std::cerr << "usage: " << argv[0] << " N M" << std::endl;
        return 1;
    }
    
    unsigned long long total_size = std::stoull(argv[1]);
    unsigned long long num_threads = std::stoull(argv[2]);
    
    if(total_size < 1 || num_threads < 1)
    {
        std::cerr << "N and M must be >= 1" << std::endl;
        return 1;
    }
    
    if(num_threads > total_size) num_threads = total_size;
    
    std::vector<int> values(total_size);
    
    std::random_device rd;
    std::mt19937 rng(rd());
    std::uniform_int_distribution<> dist(0, 100);

    std::generate(values.begin(), values.end(), [&]() { return dist(rng); });
    
    double seq_sum = 0.0;
    auto start_seq = std::chrono::high_resolution_clock::now();
    for (unsigned long long i = 0; i < total_size; ++i)
    {
        seq_sum += values[i];
    }
    auto end_seq = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> seq_time = end_seq - start_seq;
    
    std::vector<TaskData> thread_blocks(num_threads);
    int chunk_size = values.size() / num_threads;
    int current = 0;

    for(unsigned long long i = 0; i < num_threads; ++i)
    {
        thread_blocks[i].data_ptr = values.data();
        thread_blocks[i].seg_begin = current;

        if(i + 1 == num_threads)
            thread_blocks[i].seg_end = values.size();
        else
            thread_blocks[i].seg_end = current + chunk_size;

        thread_blocks[i].partial_sum = 0;
        current = thread_blocks[i].seg_end;
    }
    
    auto start_multi = std::chrono::high_resolution_clock::now();
    int launched = 0;

    for (unsigned long long i = 0; i < num_threads; ++i)
    {
        int rc = pthread_create(&thread_blocks[i].thread_id, nullptr, worker, &thread_blocks[i]);
        if(rc != 0)
        {
            std::cerr << "thread create failed at: " << i
                      << " rc (" << std::strerror(rc) << ")" << std::endl;

            for(int j = 0; j < launched; ++j)
            {
                int jr = pthread_join(thread_blocks[j].thread_id, nullptr);
                if(jr != 0)
                {
                    std::cerr << "pthread_join failed for " << j
                              << " jr " << jr << " (" << std::strerror(jr) << ")" << std::endl;
                }
            }
            return 1;
        }
        ++launched;
    }

    for (int i = 0; i < launched; ++i)
    {
        int jr = pthread_join(thread_blocks[i].thread_id, nullptr);
        if(jr != 0)
        {
            std::cerr << "thread join failed " << i
                      << " jr " << jr << " (" << std::strerror(jr) << ")" << std::endl;
            return 1;
        }
    }

    auto end_multi = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double, std::milli> multi_time = end_multi - start_multi;

    double final_sum = 0.0;
    for (unsigned long long i = 0; i < num_threads; ++i)
    {
        final_sum += thread_blocks[i].partial_sum;
    }
    
    std::cout << "Time spent without threads: " << seq_time.count() << " ms" << std::endl;
    std::cout << "Time spent with " << num_threads << " threads: " 
              << multi_time.count() << " ms" << std::endl;
    
    return 0;
}
